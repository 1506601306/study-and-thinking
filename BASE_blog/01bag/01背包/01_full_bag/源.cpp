/*
	01背包问题和完全背包问题的区别是 01背包每一个物品只能访问一次
	而完全背包问题每一个物品可以访问多次

	for(int i=1;i<n;i++)
	由这个for循环确定 i 和 i-1的逻辑顺序

	假设 背包的 当前容量是v
	那么 
	a[i][v]=max(a[i-1][v],a[i-1][v-c[i]]+value[i])

	有序 i的逻辑顺序已经由外层的for循环确定了
	所以可以简化如下

	a[v]=max(a[v],a[v-c[i]]+value[i])

	现在只要保证等号右边的a[v]是i-1的原始数据，那么a[v]求的结果就是正确的

	由递归表达式可知本次递归需要访问一维数组的范围是
	  (v-c[i]) ---v
	所以可以确定里层for循环的v一定是  v>=c[i]

	需要说明的是 01背包就是每一个数组中的元素只能被访问一次，而
	完全背包是数组中的元素可以被访问若干次


	假设有物体z容量2，价值vz很大，背包容量为5，如果v的循环顺序不是逆序
	，那么外层循环跑到物体z时，内循环在v=2时，物体z被放入背包，当v=4时
	，寻求最大价值，物体z放入背包，f[4]=max{f[4],f[2]+vz}，
	这里毫无疑问后者最大，那么此时f[2]+vz中的f[2]已经装入了一次物体z
	，这样一来该物体被装入背包两次了就，不符合要求，如果逆序循环v
	，这一问题便解决了。

	这是反证法 证明 01 逆序的原因

	理论证明如下

	当逆序的时候，访问数组的上界  是v， v每次都会较小，数组的下界
	为 v-c[i]每次也会现在， 访问的数组区间是固定的

	 但是，由于 v[i]的不确定行，只能倒序才能保证，数据的纯洁性，
	 因为它不会修改，只会访问，
	 而正序是已经访问修改过的了
	 f[4]=max{f[4],f[2]+vz}
	 但拿出这个式子来看，不论倒叙还是正序 的话，毫无疑问是没有问题的
	 有问题的只是，当访问到f[4] 的时候f[2]的数据时候被修改过，如果是
	 正序表示的是这次当背包容量等于2的最优解，而不是上一次背包容量
	 为2的最优解，所以说正序就变成了完全背包问题了，而逆序则因为
	 没有修改过所以为01背包问题
*/