<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="0FNbiBWk1FugWYo-RiGxQyIHebGeLoXp3HB7AxIFKy8" />
    <meta name="baidu-site-verification" content="tYoUqpkCCv" />
    <meta name="baidu-site-verification" content="IGN97NW90O" />
    
    <title>从webWorker到serviceWorker | ouvenzhang的博客</title>

    <meta http-equiv="x-dns-prefetch-control" content="on" />
    <link rel="dns-prefetch" href="cdnjs.cloudflare.com" />
    <link rel="dns-prefetch" href="1.url.cn" />

    <meta name="description" itemprop="description" content="从webWorker到serviceWorker,serviceWorker,webWorker ">
    <meta itemprop="name" content="从webWorker到serviceWorker">
    <meta itemprop="image" content="http://ouvens.github.io/blog/assets/logo.png">
    <meta itemprop="keywords" name="keywords" content="从webWorker到serviceWorker,serviceWorker,webWorker ">

    
    <meta name="author" content="ouvenzhang">
    <meta name="copyright" content="&copy; ouvenzhang 2017">
    <meta name="protocol" content="1">
    

    <!-- External libraries -->
    <link rel="stylesheet" href="/assets/css/iconfont.css">
    <link rel="stylesheet" href="/css/monokai_sublime.css">

    <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">
  	<link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    
  	<meta name="msapplication-TileColor" content="#ffffff">
  	<meta name="theme-color" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icons/icon.png">

  	<!-- Site styles -->
    <link rel="stylesheet" href="/css/main.css">

    <link rel="alternate" type="application/rss+xml" title="极限前端" href="http://ouvens.github.io//feed.xml" />
    <script>
    // 访问统计
    var domain = 'jixianqianduan.com';
    var oldDomain = 'ouvens.github.io';
    if(location.host === domain){
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "//hm.baidu.com/hm.js?b536b128dc21c3d18fdc028f0609e3f0";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    }else if(location.host === oldDomain){
        window.location.href = location.href.replace(oldDomain, domain);
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "//hm.baidu.com/hm.js?041efd2cb345ca1b9dbdbb2383cb716d";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    }

    // 链接提交

    if(location.protocol === 'https'){
        !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,t=document.referrer;if(!e.test(r)){var o="https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif";t?(o+="?r="+encodeURIComponent(document.referrer),r&&(o+="&l="+r)):r&&(o+="?l="+r);var i=new Image;i.src=o}}(window);
    }else{
        !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
    }


    </script>
</head>

    <body>
        <div class="navigation" role="banner">
    <div class="navigation-wrapper">
    <a href="/" class="logo">
    	
      <img src="/assets/logo.png" alt="极限前端">
      
    </a>
    <span class="search-input" id="search-input">
      <input type="text" value="" class="search-text" placeholder="输入搜索关键字">
      <i class="icon-font i-search search-btn"></i>
    </span>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
    	<i class="icon-font i-list fa fa-bars"></i>
    </a>
    <span class="nav" role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
      	
          
          <li class="nav-link">
            <a href="/about/">关于</a>
          </li>
          
        
          
        
          
        
          
        
          
          <li class="nav-link">
            <a href="/category/">所有文章</a>
          </li>
          
        
          
          <li class="nav-link">
            <a href="/tags/">标签分类</a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          <li id="github-info" class="nav-link" title="https://github.com/ouvens">
            <a class="github-info" href="https://github.com/ouvens" target="_blank">
            <img src="/assets/github.png" height="34" width="130" alt="github地址"></a>
          </li>
      </ul>
    </span>
  </div>
</div>

            <div class="page-content">
        <div class="post">
<div class="post-header-container has-cover">
	<header class="post-header">
	  <h1 class="title">从webWorker到serviceWorker</h1>
	  <p class="info">by <strong>ouven</strong></p>
	</header>
</div>
<div class="wrapper">



<div class="post-meta">
	<div class="post-date">2014年06月05日</div>
	<div class="post-categories">
	 in  
		<a target="_blank" href="/category/?cate=frontend-javascript">Frontend-javascript</a>
	  
	</div>
</div>	

<article class="post-content">
  <h2 id="webworkerserviceworker">从webWorker到serviceWorker</h2>

<p>http://www.w3.org/TR/2014/WD-service-workers-20140508/#introduction
下面将从webWorker、serviceWorker和为什么使用serviceWorker三个方面进行讨论</p>

<h3 id="web-worker">一、Web worker</h3>

<p>要了解serviceworker，先的认识下webworker，也可以了解一下二者的共同点，并予以区分。</p>

<p>Web Workers 是 现代浏览器 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行。JavaScript语言执行采用的是单线程模型，也就是说，所有任务排成一个队列，一次只能做一件事。但是有了webworker后就不一样了。</p>

<h4 id="section">(1) 兼容性</h4>
<p>支持的浏览器包括IE10、Firefox (从3.6版本开始)、Safari (从4.0版本开始)、Chrome 和 Opera 11+，但是手机浏览器还不支持。</p>

<h4 id="api">(2) 基础API</h4>
<p>构造一个webworker：new Worker(path) ，返回一个Worker对象。</p>

<p><strong>返回的对象</strong></p>

<p>onerror：用于worker出错处理
onmessage：用户主线程和worker线程传递数据，可以使字符串数字或对象，但是safari浏览器不支持对象，需要用stringify和parse转化。当然和可以使用addeventListener(“message”,function(){});
煮个栗子：(例子代码见附件)</p>

<p><strong>输出</strong></p>

<p>如何结束worker：
主页面worker.terminate();或worker自销毁self.close();或者关闭页面</p>

<p><strong>sharedworker：</strong>
除了webWorker，还有另一类sharedworker支持多个浏览器窗口共享同一个worker，单个页面关闭，worker并不结束，需关闭浏览器。但这里不做深入讨论</p>

<p>importScripts:
worker内部引用文件的方法，可以将worker分成不同的多个文件，然后使用importScripts加载，并可以实现文件的动态加载。就像html中使用script标签引入js一样。
global worker上下文:
前面提到在worker中不能使用window对象和docuemnt对象，是因为一个webworker拥有一个独立的运行环境Workerglobalscope并和浏览器的环境独立，Workerglobalscope环境包括：
* JavaScript的全局对象：JSON、Date()、Array
*self自身引用
*location对象，但是其属性都是只读的，改了也影响不到调用者
*navigator对象，但修改了部分属性
*setTimeout()、setInterval()及其对应清除方法
*addEventListener()、removeEventListener()
http://dev.w3.org/html5/workers/#dedicatedworkerglobalscope</p>

<p><strong>(3) 局限性</strong></p>

<p>1.同源限制。webworker不能跨域加载JS
2.DOM限制。worker内代码不能访问dom，原因是worker有自己独立的global worker环境，不是浏览器window，所以alert(),dom等操作无法进行
3.文件限制。子线程无法读取本地文件，即worker只能加载网络文件。
4.不是每个浏览器都支持这个新特性，且各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行</p>

<h2 id="serviceworker">二、ServiceWorker</h2>
<p>Service Worker是基于Web Worker的事件驱动的，他们执行的机制都是新开一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线程的渲染。而Service Worker，我们可以用它来进行本地缓存或请求转发，相当于一个浏览器端本地的proxy。</p>

<p>例如使用Service Worker来进行缓存，是用javascript代码来拦截浏览器的http请求，并设置缓存的文件，直接返回，不经过web服务器，然后，我们就可以开发基于浏览器的离线应用。这使得我们的web应用减少对网络的依赖。
如果我们使用了Service Worker做缓存，浏览器http请求会先经过Service Worker，通过url mapping去匹配，如果匹配到了，则使用缓存数据，如果匹配失败，则继续执行你指定的动作。一般情况下，匹配失败则让页面显示“网页无法打开”。</p>

<p>上面是Service Worker的一个基本使用场景，当然还有更多，先了解一下serviceWorker。</p>

<h4 id="section-1">(1) 兼容性</h4>

<p>https://jakearchibald.github.io/isserviceworkerready/ (目前API支持现状，有兴趣的自己看，反正就是基本上只有chrome测试版和FF nightly版本支持)</p>

<p>chrome版本下要支持还要开启serviceWorker支持，打开chrome://flags/</p>

<p>此外特定的API还需要特定的环境：</p>

<p>此外还有开启实验平台、使用chrome canary测试版本，这个确实比较麻烦。但是实际上使用最新的canary版本也无法完全支持草案中的所有API，实验时使用的chrome稳定37版本和canary 40版本环境。可能后面新版本又会修改。</p>

<h4 id="serviceworker-1">(2) serviceWorker介绍</h4>

<p>ServiceWorkerGlobalScope部分作用域定义如下</p>

<p>可以看出，这个webworker的scope有点不一样，但是也有些共同部分
scriptCache：worker的文件一旦注册使用，会被缓存到浏览器中，需要手动清理掉，例如：
，注册使用了sw.js，sw.js修改后必须清理缓存后才生效</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="nx">client</span><span class="err">：返回</span><span class="nx">serviceworkClients</span><span class="err">对象</span>

<span class="nx">scope</span><span class="err">：返回</span><span class="nx">serviceworker</span><span class="err">的</span><span class="nx">url</span><span class="err">路径数组，并和</span><span class="nx">serviceworker</span><span class="err">的注册事件关联，一旦注册，</span><span class="nx">serviceworker</span><span class="err">的路径就会在</span><span class="nx">scope</span><span class="err">中。</span>

<span class="err">注册与销毁：</span><span class="nx">register</span><span class="o">&amp;</span><span class="nx">unregister</span><span class="err">，</span><span class="nx">register</span><span class="err">执行后返回一个</span><span class="nx">Promise</span><span class="err">对象，所以要支持</span><span class="nx">serviceWorker</span><span class="err">浏览器必须先支持</span><span class="nx">Promise</span>
<span class="err">事件</span><span class="nx">Event</span><span class="err">:</span>
<span class="o">*</span><span class="nx">install</span><span class="err">：</span><span class="nx">worker</span><span class="err">使用</span><span class="nx">register</span><span class="err">注册时会触发</span><span class="nx">install</span><span class="err">事件</span>
<span class="o">*</span><span class="nx">activate</span><span class="err">：</span><span class="nx">worker</span><span class="err">使用</span><span class="nx">register</span><span class="err">注册时也会触发</span><span class="nx">activate</span><span class="err">事件</span>
<span class="o">*</span><span class="nx">fetch</span><span class="err">：浏览器发送请求时会产生</span><span class="nx">fetch</span><span class="err">事件，此时可以调用一个请求响应的对象，或者可以使用</span><span class="nx">responseWith</span><span class="err">来指定请求返回内容</span>
<span class="o">*</span><span class="nx">responseWith</span><span class="err">：</span><span class="nx">responseWith</span><span class="err">必须指定一个相应内容，否则会发生触发</span><span class="nx">error</span> <span class="nx">event</span><span class="err">，请求成功后会获得一个正确的</span><span class="nx">url</span><span class="err">。</span>
<span class="o">*</span><span class="nx">waitUtil</span><span class="err">：</span><span class="nx">waitUtil</span><span class="err">可以为</span><span class="nx">install</span><span class="err">指定时间延时，让</span><span class="nx">install</span><span class="err">的动作延后执行。</span>
<span class="o">*</span><span class="nx">replace</span><span class="err">：</span><span class="nx">install</span><span class="err">事件执行完成后会指定</span><span class="nx">replace</span>
<span class="nx">onmessage</span><span class="err">：主线程与</span><span class="nx">worker</span><span class="err">之间调用传递数据的通道</span>
<span class="nx">postMessage</span><span class="err">：同</span><span class="nx">webworkers</span><span class="err">类似，用于进行数据传递，</span><span class="nx">canary</span><span class="err">版本不支持。</span><span class="nx">stable</span><span class="err">反而支持</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>…还有一些感觉不常用的就不列出了</p>

<h4 id="section-2">(3) 煮个栗子</h4>

<p>现在要使用serviceWorkers实现请求转发，详见代码中的的 urlredirect/下代码</p>

<p>sw.js(serviceworker)中实现了对9.url.cn的请求全部转发请求返回一张图片，即把bg-logo.png换成另一张220尺寸的图片。
更多栗子见附件所示。</p>

<p>再来个onmessage的栗子,详见代码中的的 postMessage/下代码：</p>

<p>其实这个就和webworker一样了，可以理解，serviceWorker可以认为是一种改进后的webWorker。webworker做的是多线程，serviceworker则是用webworker做了个与网络请求相关封装，来监听一些网络事件。当然serviceworker也可以来做很多事情，例如离线缓存应用，甚至替代fiddler作为调试工具。
目前serviceworker的草案还在更新中，部分api仅在FF nightly和chrome canary中使用，相对还需要较大的完善。</p>

<h4 id="section-3">(4)注意事项：</h4>

<p>处于安全考虑，serviceworker一般用在https上，原因有几点:
*防止人为中间层攻击
*推动https使用
*开发工具可以比较自由安全
*https未来会在web中越来越广泛
另外serviceworker一般不能放在cdn上，但是可以通过importscript()来导入cdn上的资源，</p>

<h4 id="section-4">(5)扩展：</h4>

<p>根据10月草案，serviceworker未来可能会增加后台同步，任务调度和消息推送API。</p>

<h4 id="chrome-canary">(6)chrome canary离线小恐龙的游戏</h4>

<p>基于serviceworker，chrome canary版本 (chrome37稳定版的好像不行) 在网络不可用时会显示小恐龙冒险的离线游戏，按下空格键，就可以开始呵呵了~~无聊的童鞋可以去试试，如果自己能做个飞机大战就更好了。</p>

<h2 id="serviceworker-2">三、为什么要使用serviceworker</h2>

<h4 id="section-5">3.1 未来我们想要做的</h4>

<p>未来的web 应用将是离线可用的，而且是能够增量更新的，尤其是在PC客户端的应用</p>

<h4 id="web">3.2 目前web应用缓存解决方案与不足</h4>

<p>目前主要的webapp缓存解决方案主要有以下4种，大家一看都懂，这里只是过一下</p>

<p><strong>3.2.1 基于浏览器头信息的缓存方式</strong>
    这种方式的缓存过程如下：</p>

<p>说白了，使用浏览器头信息缓存的主要有了两种，一种是判断静态资源http头部的Etag和Last-Modified是否修改，修改则重新请求，否则忽略；当然还有一种根据expires过期时间来判断的，原理一样，但是这两种方法都必不可少的至少会产生大量http请求，即使返回304。而且一旦离线，浏览器就无计可施了。</p>

<p><strong>3.2.2 使用APP Cache</strong></p>

<p>html5提供了App cache来解决静态文件存储的问题，它通过将要缓存的静态文件声明在一个manifest文件清单里，然后在要缓存的html里通过manifest属性关联清单文件即可在下次载入html时优先加载缓存清单中列出的静态文件。相对于浏览器 默认的土鳖方法，静态文件的缓存变得更加可控了。</p>

<p>但是，有些问题依然有些棘手：</p>

<ol>
  <li>
    <p>对manifest文件更新，会重新请求所有文件，实际上可能只更新了很少量文件。（ 虽然重新请求资源会返回304， 但每个文件还会发起请求，还是发起了网络请求)、针对此点可以只更新需要更新的文件， 比如可以建立一个文件版本或者MD5映射，对相同版本或者MD5不再请求。</p>
  </li>
  <li>
    <p>manifest文件每次都会请求，我们可以按照一定时间更新一次，或者启动时更新一次，但一旦改变更新就是全量更新</p>
  </li>
  <li>
    <p>当然也可以在打开app之前预缓存，提前下载文件或者更新manifest文件。</p>
  </li>
</ol>

<p>但这些解决方案，是不是仍然觉得很麻烦，而且依然会有大量的304请求，有木有。</p>

<p><strong>3.2.3 使用localstorage存储</strong></p>

<p>html5支持的，现对于cookie的确丰富了许多，也扩大了容量，方便易用的API也被广泛接受，但是几个问题：
一是无法对静态文件进行存储，二是大小限制，虽然各个浏览器的localstorage最大容量限制也不一样，但是最大的也只是IE9下的7MB，所以要应对离线应用，localstorage仍然是捉襟见肘。</p>

<p><strong>3.2.4 indexedDB缓存</strong></p>

<p>原理说起来比较简单，IndexedDB的做法是，把一些数据存储到浏览器的indexedDB中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用，而且不需要你去写特定的sql语句来对数据进行操作，它是nosql的，数据形式使用的是json。这种存储数据的方式似乎无懈可击，容量足够，存取自由，但是对于静态文件就极其麻烦了。</p>

<h4 id="serviceworker-3">3.3 基于这些，所以我们选择了serviceWorker</h4>

<p>它可以是浏览器提供给用户的一个上网代理，通过fetch拦截到用户的所用请求，可以不向服务器发送，并可以将请求转向本地缓存或其它资源文件的加载，无论是数据还是静态文件，然后可以通过javascript的操作进行增量更新应用数据，而且同时不阻塞浏览器的渲染进程。这就很好的解决了我们的问题。虽然目前浏览器支持的程度比较差，但是浏览器的发展速度会很快让我们用到它的。</p>

<h2 id="section-6">四、总结</h2>

<p>(1) webworker 现在可以在浏览器端做多线程操作，但比较限制</p>

<p>(2) serviceworker是在webworker基础上实现的，它可认为是使用了webworker技术来处理网络请求、响应等方面的事务</p>

<p>(3) 两者目前浏览器兼容性很不好，尤其是serviceworker，草案在更新，特性没有完整，chrome的各分支版本支持都不一样，但仍然还是可以根据这些特性进行一些有趣的开发。</p>

<p>(4)serviceworker可以带给我们很多</p>

<p>参考文档
https://jakearchibald.github.io/isserviceworkerready/ (api支持性现状介绍)
http://www.serviceworker.org/# (git主页)
http://www.w3.org/TR/2014/WD-service-workers-20140508/#introduction (w3c介绍)
http://jakearchibald.com/2014/service-worker-first-draft/ (serviceWorker草案)
https://github.com/jakearchibald/isserviceworkerready (样例代码)
https://slightlyoff.github.io/ServiceWorker/spec/service_worker/ (10月份更新的草案)</p>

</article>


<div class="tags">
	<strong>Tags:</strong> <a target="_blank" href="/tags/?tag=serviceWorker">serviceWorker</a>,&nbsp;<a target="_blank" href="/tags/?tag=webWorker">webWorker</a>
</div>


	<script src="/assets/js/github.comment.js"></script>
	<div class="gc-comments" data-repos="ouvens/ouvens.github.io" data-issues="3" >
	    <div class="gc-comments-title">
	        评论
	    </div>
	    <div class="gc-comments-info">
	        想在此留下评论，请访问 <a href="issues_link">issues_link</a> 提交评论
	    </div>
	</div>
</div>
</div>


    </div>
    
<div class="qr-code qr-code-pay" title="加个微信交流交流">
    <img src="/assets/qrcode/qr-code-person.jpg" width="200" height="200" alt="公众号">
    <p>加我赏红包，哈哈哈</p>
</div>

<div class="qr-code qr-code-wx" title="定期获取更新动态">
    <img src="/assets/qrcode/qrcode.jpg" width="200" height="200" alt="公众号">
    <p>欢迎关注 <strong>极限前端</strong> 公众号</p>
</div>


    
<footer class="site-footer">
  <div class="wrapper">
    <h3 class="footer-heading">极限前端</h3>
    <div class="site-navigation">
    	<p><strong>站内</strong></p>
      <ul class="pages">
        
        
          <li class="nav-link"><a href="/about/">关于</a>
        
        
        
        
        
        
        
        
        
          <li class="nav-link"><a href="/category/">所有文章</a>
        
        
        
          <li class="nav-link"><a href="/tags/">标签分类</a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
    </div>
    <div class="site-contact">
    	<p><strong>相关链接</strong></p>
        <ul class="social-media-list">
      	<li>
      		<a href="mailto:1025224452@qq.com">
	      		<i class="icon-font i-star"></i>
	      		<span class="username">1025224452@qq.com</span>
      		</a>
      	</li>

      	
	      	
	      	<li>
	           <a href="https://github.com/ouvens" title="Fork me on GitHub">
	               <i class="icon-font i-heart"></i>
	               <span class="username">ouvens</span>
	           </a>
	        </li>
	      	
      	

      </ul>
    </div>
    <div class="site-signature">
    	<p class="rss-subscribe text"><strong>订阅<a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">极限前端, 极限前端社区, ouven的博客, ouvenzhang的博客, www.jixianqianduan.com, github地址, 前端技术, 讲述前端高效技术与前沿。</p>
    </div>
  </div>
</footer>

<!-- Scripts -->
<script src="//1.url.cn/jslib/jquery/1.9.1/jquery.min.js" defer></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js" defer></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/js/lightbox.min.js" defer></script>

<script src="/assets/js/main.js" defer></script>

    </body>
</html>
