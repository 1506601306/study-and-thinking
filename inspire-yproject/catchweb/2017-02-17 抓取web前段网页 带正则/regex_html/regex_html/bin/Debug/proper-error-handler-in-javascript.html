<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="0FNbiBWk1FugWYo-RiGxQyIHebGeLoXp3HB7AxIFKy8" />
    <meta name="baidu-site-verification" content="tYoUqpkCCv" />
    <meta name="baidu-site-verification" content="IGN97NW90O" />
    
    <title>【原译】javascript中的错误处理 | ouvenzhang的博客</title>

    <meta http-equiv="x-dns-prefetch-control" content="on" />
    <link rel="dns-prefetch" href="cdnjs.cloudflare.com" />
    <link rel="dns-prefetch" href="1.url.cn" />

    <meta name="description" itemprop="description" content="【原译】javascript中的错误处理,错误 ">
    <meta itemprop="name" content="【原译】javascript中的错误处理">
    <meta itemprop="image" content="http://ouvens.github.io/blog/assets/logo.png">
    <meta itemprop="keywords" name="keywords" content="【原译】javascript中的错误处理,错误 ">

    
    <meta name="author" content="ouvenzhang">
    <meta name="copyright" content="&copy; ouvenzhang 2017">
    <meta name="protocol" content="1">
    

    <!-- External libraries -->
    <link rel="stylesheet" href="/assets/css/iconfont.css">
    <link rel="stylesheet" href="/css/monokai_sublime.css">

    <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">
  	<link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    
  	<meta name="msapplication-TileColor" content="#ffffff">
  	<meta name="theme-color" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icons/icon.png">

  	<!-- Site styles -->
    <link rel="stylesheet" href="/css/main.css">

    <link rel="alternate" type="application/rss+xml" title="极限前端" href="http://ouvens.github.io//feed.xml" />
    <script>
    // 访问统计
    var domain = 'jixianqianduan.com';
    var oldDomain = 'ouvens.github.io';
    if(location.host === domain){
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "//hm.baidu.com/hm.js?b536b128dc21c3d18fdc028f0609e3f0";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    }else if(location.host === oldDomain){
        window.location.href = location.href.replace(oldDomain, domain);
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "//hm.baidu.com/hm.js?041efd2cb345ca1b9dbdbb2383cb716d";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    }

    // 链接提交

    if(location.protocol === 'https'){
        !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,t=document.referrer;if(!e.test(r)){var o="https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif";t?(o+="?r="+encodeURIComponent(document.referrer),r&&(o+="&l="+r)):r&&(o+="?l="+r);var i=new Image;i.src=o}}(window);
    }else{
        !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
    }


    </script>
</head>

    <body>
        <div class="navigation" role="banner">
    <div class="navigation-wrapper">
    <a href="/" class="logo">
    	
      <img src="/assets/logo.png" alt="极限前端">
      
    </a>
    <span class="search-input" id="search-input">
      <input type="text" value="" class="search-text" placeholder="输入搜索关键字">
      <i class="icon-font i-search search-btn"></i>
    </span>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
    	<i class="icon-font i-list fa fa-bars"></i>
    </a>
    <span class="nav" role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
      	
          
          <li class="nav-link">
            <a href="/about/">关于</a>
          </li>
          
        
          
        
          
        
          
        
          
          <li class="nav-link">
            <a href="/category/">所有文章</a>
          </li>
          
        
          
          <li class="nav-link">
            <a href="/tags/">标签分类</a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          <li id="github-info" class="nav-link" title="https://github.com/ouvens">
            <a class="github-info" href="https://github.com/ouvens" target="_blank">
            <img src="/assets/github.png" height="34" width="130" alt="github地址"></a>
          </li>
      </ul>
    </span>
  </div>
</div>

            <div class="page-content">
        <div class="post">
<div class="post-header-container has-cover">
	<header class="post-header">
	  <h1 class="title">【原译】javascript中的错误处理</h1>
	  <p class="info">by <strong>ouven</strong></p>
	</header>
</div>
<div class="wrapper">



<div class="post-meta">
	<div class="post-date">2016年05月12日</div>
	<div class="post-categories">
	 in  
		<a target="_blank" href="/category/?cate=article-translation">Article-translation</a>
	  
	</div>
</div>	

<article class="post-content">
  <h3 id="javascript">【原译】javascript中的正确错误处理</h3>

<p>  <a href="http://www.sitepoint.com/proper-error-handling-javascript/">A Guide to Proper Error Handling in JavaScript</a></p>

<p>  这是关于JavaScript中异常处理的故事。如果你相信<a href="https://en.wikipedia.org/wiki/Murphy%27s_law">墨菲定律</a>，那么任何事情都可能出错，不，一定会出错!这篇文章中我们来看下JavaScript中的出错处理。文章会覆盖异常处理使用的正反例，然后看下ajax的异步处理。</p>

<p>  JavaScript的事件驱动机制让JavaScript更加丰富，浏览器好比就是一个事件驱动的机器，错误也是一种事件。当一个错误发生时，一个事件就在某个点抛出。理论上，有人会说错误是Javascript中的简单事件。如果你觉得是这样，那你就要好好去看看了。另外这篇文章只关注浏览器端的JavaScript的情况。</p>

<p>  这篇文章将在《<a href="http://www.sitepoint.com/exceptional-exception-handling-in-javascript/">Exceptional Exception Handling in JavaScript</a>》这篇文章的概念基础上进行解释。解释起来就是，当发生错误时，JavaScript会去调用栈检查异常事件。如果你对此不熟悉建议先去看看基础的东西。我们的目的是探索处理异常的必要性，接下来你会看到一个 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try...catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 块语句，你要认真思考。</p>

<h3 id="section">例子</h3>

<p>  例子的代码在<a href="https://github.com/sitepoint-editors/ProperErrorHandlingJavaScript">github</a>上，而且最终展示成这样：</p>

<p><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455237011proper_error_handling_javascript_1.jpg" alt="" /></p>

<p>  所有的按钮点击是都会触发”炸弹”，这个炸弹模拟了一个抛出的 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>TypeError<span class="w">
</span></pre></td></tr></tbody></table>
</code> 异常。下面是这个模块单元测试的定义：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>function error() {
    var foo = {};
    return foo.bar();
}
</pre></td></tr></tbody></table>
</div>
</div>

<p>  开始时，这个函数定义了一个空的对象<code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>foo<span class="w">
</span></pre></td></tr></tbody></table>
</code>，注意 	<code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>bar()<span class="w">
</span></pre></td></tr></tbody></table>
</code> 没有在任何地方定义，我们用一个测试用例来看下它是如何引爆炸弹的。</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>it('throws a TypeError', function () {
    should.throws(target, TypeError);
});
</pre></td></tr></tbody></table>
</div>
</div>

<p>  这个单元测试是用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>mocha<span class="w">
</span></pre></td></tr></tbody></table>
</code> 和 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>should.js<span class="w">
</span></pre></td></tr></tbody></table>
</code> 写的。<code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>mocha<span class="w">
</span></pre></td></tr></tbody></table>
</code> 是一个测试框架，<code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>should.js<span class="w">
</span></pre></td></tr></tbody></table>
</code> 是一个断言库。如果你熟悉它们后，你会感觉写起来很爽。测试一般使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>it('description')<span class="w">
</span></pre></td></tr></tbody></table>
</code> 开始，然后在 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>should<span class="w">
</span></pre></td></tr></tbody></table>
</code> 中使用 ` pass/fail` 结束。好消息是测试用例可以在node端运行而不需要浏览器。我建议多关注这些测试，因为它们能帮助我们提升代码的质量。</p>

<p>  正如所显示的， <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>error()<span class="w">
</span></pre></td></tr></tbody></table>
</code> 定义了一个空的对象，然后尝试访问一个方法，因为 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>bar()<span class="w">
</span></pre></td></tr></tbody></table>
</code> 方法在对象中不存在而会抛出一个异常。使用JavaScript这种动态语言运行一定会出错。</p>

<h3 id="section-1">错误的方式</h3>

<p>  对于一些错误的处理，我从按钮的而事件中抽离出异常处理的方式，下面是单元测试函数的代码：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>function badHandler(fn) {
    try {
        return fn();
    } catch (e) { }
    return null;
}
</pre></td></tr></tbody></table>
</div>
</div>

<p>  这个处理函数接收一个 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>fn<span class="w">
</span></pre></td></tr></tbody></table>
</code> 回调函数作为输入，这个函数然后在处理器函数里面被调用，单元测试如下：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre>it('returns a value without errors', function() {
    var fn = function() {
        return 1;
    };
    var result = target(fn);
    result.should.equal(1);
});

it('returns a null with errors', function() {
    var fn = function() {
        throw Error('random error');
    };
    var result = target(fn);
    should(result).equal(null);
});
</pre></td></tr></tbody></table>
</div>
</div>

<p>  如你所见，这个糟糕的处理函数如果有地方出错就会返回null，回调函数 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>fn()<span class="w">
</span></pre></td></tr></tbody></table>
</code> 可以指向一个正确的方法或者一个异常，下面的点击处理函数会显示最终的处理结果。</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>(function (handler, bomb) {
    var badButton = document.getElementById('bad');

    if (badButton) {
        badButton.addEventListener('click', function () {
            handler(bomb);
            console.log('Imagine, getting promoted for hiding mistakes');
        });
    }
}(badHandler, error));
</pre></td></tr></tbody></table>
</div>
</div>

<p>  可恶的是，这里返回了一个null，当我想找哪里出了问题时整个人都蒙逼了。这种失败沉默的方式会影响用户体验和数据混乱。更令人崩溃的是，我花了几个小时来进行debugg，但却没有使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code>，这个糟糕的处理函数吞没了错误并认为它没有问题， 这样继续执行下去不会降低代码质量，但是隐藏的错误未来会让你花几个小时来debugg。在一个多层的深调用时，基本上不可能发现哪里出了问题。而在这些少数的地方使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 是正确的。但是一旦进入错误处理函数，就比较糟糕了。</p>

<p>  失败沉默策略会让你不容易发现错误所在，JavaScript提供了一个更优雅的方式来处理这些问题。</p>

<h3 id="section-2">比较差的方式</h3>

<p>  继续，是时候说下一个稍微好点的方法了。我先跳过事件绑定到dom上的部分。这个函数处理和刚刚我们看到的没什么不同。所不同的是单元测试中它处理异常的方式。</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre>function uglyHandler(fn) {
    try {
        return fn();
    } catch (e) {
        throw Error('a new error');
    }
}

it('returns a new error with errors', function () {
    var fn = function () {
        throw new TypeError('type error');
    };
    should.throws(function () {
        target(fn);
    }, Error);
});
</pre></td></tr></tbody></table>
</div>
</div>

<p>  这里定义在原来的基础上改进了。这里异常事件在调用栈中进行冒泡，我喜欢的是现在错误现在会离开方便debugg的调用栈。在这个异常中，解释器会遍历整个栈寻找另一个错误处理函数。这样就可以有机会在调用栈的顶端处理这些错误。不幸的是，因为这个方法，我不知道错误是从哪个地方抛出来的。所以我又得反向遍历这个栈找到错误异常的源头。但至少我知道某个地方出错了，并能找到是哪个地方抛出的错误。</p>

<h3 id="section-3">离开调用栈</h3>

<p>  所以，一个抛出异常处理的方法是直接调用栈的顶端使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code>，就像：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>function main(bomb) {
    try {
        bomb();
    } catch (e) {
        // Handle all the error things
    }
}
</pre></td></tr></tbody></table>
</div>
</div>

<p>  但是，记住我说的浏览器是事件驱动的。是的，JavaScript中的错误也不过是一个事件。解释器在当前的执行上下文中执行后释放。结果是，我们可以利用一个 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>onerror<span class="w">
</span></pre></td></tr></tbody></table>
</code> 的全局异常事件处理函数，它大概是这样的：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre>if(window.addEventListener){
	window.addEventListener('error', function (e) {
	    var error = e.error;
	    console.log(error);
	});
}else if(window.attachEvent){
	window.attachEvent('onerror', function (e) {
	    var error = e.error;
	    console.log(error);
	});
}else{
	window.onerror = function(e){
		var error = e.error;
	    console.log(error);
	}
}

</pre></td></tr></tbody></table>
</div>
</div>

<p>  这个处理函数能捕获任何执行上下文中的错误异常。包括任何类型的任何错误。而且它能定位到代码中的错误处理。就像其它任何事件一样，你能捕获特定错误的具体信息。这样能使异常处理器只专注于一件事情，如果你允许这样做的话。这些处理函数也可以在任何时候注册，解释器会尽可能的遍历更多的处理函数，我们再也不用使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 块这种带有瑕疵的debug方式了。尤其是在对待像JavaScript这类事件驱动机制的语言时，onerror的优势就更大了</p>

<p>  现在我们可以使用全局处理函数来离开栈了，我们可以用来干什么呢。毕竟，调用栈还是存在的。</p>

<h3 id="section-4">捕获栈信息</h3>

<p>  调用栈在定位问题时超级有用。好消息是，浏览器提供了这个信息。理所当然，查看错误异常中的栈属性不是标准的一部分，但是只在新的浏览器中可以使用。所以，你就可以这样来把错误日志发送给服务器了。</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>window.addEventListener('error', function (e) {
    var stack = e.error.stack;
    var message = e.error.toString();
    if (stack) {
        message += '\n' + stack;
    }
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/log', true);
    xhr.send(message);
});
</pre></td></tr></tbody></table>
</div>
</div>

<p>  可能从代码样例来说不是很明显，但是上面的代码一定会出错。上面提到了，每个处理函数都只处理一个功能。我关心的是这些信息是怎样被服务器捕获的。如下：</p>

<p><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455237138proper_error_handling_javascript_2.jpg" alt="" /></p>

<p>  这些信息来自FireFox 46的开发版本，通过一个正确的错误处理函数，记录了出错的情况。这里没必要隐藏错误，我可以看到什么地方出现的什么错误。这样代码debugg就很爽了。这些信息也可以保存在持续化缓存中以便于以后分析。</p>

<p>  调用栈对于debugg来说是很有用的，永远不要低估调用栈的力量。</p>

<h3 id="section-5">异步处理</h3>

<p>  处理异步时，JavaScript的异步处理代码不在当前的指向上下文中，这意味着 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 语句会有问题（不能捕获到异常）：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>function asyncHandler(fn) {
    try {
        setTimeout(function () {
            fn();
        }, 1);
    } catch (e) { }
}
</pre></td></tr></tbody></table>
</div>
</div>

<p>  单元测试的结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre>it('does not catch exceptions with errors', function () {
    var fn = function () {
        throw new TypeError('type error');
    };
    failedPromise(function() {
        target(fn);
    }).should.be.rejectedWith(TypeError);
});

function failedPromise(fn) {
    return new Promise(function(resolve, reject) {
        reject(fn);
    });
}
</pre></td></tr></tbody></table>
</div>
</div>

<p>  我必须用promise包含这个处理器来获取这个错误。注意的是，一个未被处理的异常发生时，尽管我将代码使用 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 包含起来了，是的， <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 只能在单一的作用域内有效。在一个异常被抛出的同时，解释器就会从 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 中离开，ajax也是一样的。所以有两种选择，一种是在异步调用里面捕获异常：</p>

<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>setTimeout(function () {
    try {
       fn();
    } catch (e) {
        // Handle this async error
    }
}, 1);
</pre></td></tr></tbody></table>
</div>
</div>

<p>  这种方法很有效，但是很多地方可以改进。首先，<code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 块在这里用很混乱。实际上，之前是这么做的，但是有问题。另外，V8引擎不鼓励<a href="https://github.com/nodejs/node-v0.x-archive/wiki/Best-practices-and-gotchas-with-v8">在函数中使用try-catch</a>(V8 是chrome和nodejs中的JavaScript引擎)。它们的建议是最外层写这些块。</p>

<p>  所以我们该怎么办？我说过全局异常处理可以在任何执行上下文中执行，如果给window对象增加一个错误处理函数，就OK了。这样是不是既能处理捕获处理错误又能保持代码的优雅呢。全局的错误处理能让你的代码干净整洁。</p>

<p>  下面是服务器收集到的错误日志，注意的是如果你使用同样的代码再不同浏览器上执行，你会看到收集到的日志也是不同的：</p>

<p><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455237145proper_error_handling_javascript_3.jpg" alt="" /></p>

<p>  这个处理函数甚至告诉我们错误是从异步代码中抛出的吗，它告诉我们来至 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>setTimeout()<span class="w">
</span></pre></td></tr></tbody></table>
</code> 函数。</p>

<h3 id="section-6">结论</h3>

<p>  总得来说，进行异常处理至少有两种方法。一个是失败沉默的方法，在错误发生时忽略错误不作为而不影响后面的继续执行。另一种是发生后迅速找到错误发生的地方。明显我们知道那种方法更具有优势。我的选择是：不要隐藏错误。没人会因为你代码中有问题而鄙视你，用户多试一次是可以接受的。代码距离完美是很远的，错误也是不可避免的，重要的是你发现错误后会怎么做。</p>

<p>  译者注：文章浅显的分析了错误处理的方式和一些正反案例，其实处理错误的最终目的还是提供前端代码的质量，关于错误处理上报可以参考下 <a href="https://github.com/BetterJS/badjs-report">badjs</a> 的思路，基于现代前端开发模块化的基础，使用全局 <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>onerror<span class="w">
</span></pre></td></tr></tbody></table>
</code> 和  <code class="highlighter-rouge"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>try-catch<span class="w">
</span></pre></td></tr></tbody></table>
</code> 相结合的方式更能有效进行错误定位。</p>

<hr />

<p>原文作者：Camilo Reyes</p>

<p>原译：ouven</p>

<p>原文地址： http://www.sitepoint.com/proper-error-handling-javascript/</p>


</article>


<div class="tags">
	<strong>Tags:</strong> <a target="_blank" href="/tags/?tag=错误">错误</a>
</div>


	<script src="/assets/js/github.comment.js"></script>
	<div class="gc-comments" data-repos="ouvens/ouvens.github.io" data-issues="3" >
	    <div class="gc-comments-title">
	        评论
	    </div>
	    <div class="gc-comments-info">
	        想在此留下评论，请访问 <a href="issues_link">issues_link</a> 提交评论
	    </div>
	</div>
</div>
</div>


    </div>
    
<div class="qr-code qr-code-pay" title="加个微信交流交流">
    <img src="/assets/qrcode/qr-code-person.jpg" width="200" height="200" alt="公众号">
    <p>加我赏红包，哈哈哈</p>
</div>

<div class="qr-code qr-code-wx" title="定期获取更新动态">
    <img src="/assets/qrcode/qrcode.jpg" width="200" height="200" alt="公众号">
    <p>欢迎关注 <strong>极限前端</strong> 公众号</p>
</div>


    
<footer class="site-footer">
  <div class="wrapper">
    <h3 class="footer-heading">极限前端</h3>
    <div class="site-navigation">
    	<p><strong>站内</strong></p>
      <ul class="pages">
        
        
          <li class="nav-link"><a href="/about/">关于</a>
        
        
        
        
        
        
        
        
        
          <li class="nav-link"><a href="/category/">所有文章</a>
        
        
        
          <li class="nav-link"><a href="/tags/">标签分类</a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
    </div>
    <div class="site-contact">
    	<p><strong>相关链接</strong></p>
        <ul class="social-media-list">
      	<li>
      		<a href="mailto:1025224452@qq.com">
	      		<i class="icon-font i-star"></i>
	      		<span class="username">1025224452@qq.com</span>
      		</a>
      	</li>

      	
	      	
	      	<li>
	           <a href="https://github.com/ouvens" title="Fork me on GitHub">
	               <i class="icon-font i-heart"></i>
	               <span class="username">ouvens</span>
	           </a>
	        </li>
	      	
      	

      </ul>
    </div>
    <div class="site-signature">
    	<p class="rss-subscribe text"><strong>订阅<a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">极限前端, 极限前端社区, ouven的博客, ouvenzhang的博客, www.jixianqianduan.com, github地址, 前端技术, 讲述前端高效技术与前沿。</p>
    </div>
  </div>
</footer>

<!-- Scripts -->
<script src="//1.url.cn/jslib/jquery/1.9.1/jquery.min.js" defer></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js" defer></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/js/lightbox.min.js" defer></script>

<script src="/assets/js/main.js" defer></script>

    </body>
</html>
