#include<iostream>
#include<stdio.h>
int V[200][200];//前i个物品装入容量为j的背包中获得的最大价值
int max(int a, int b)
{
	if (a >= b)
		return a;
	else return b;
}


//问题分析：令V(i, j)表示在前i(1 <= i <= n)个物品中能够装入容量为就j(1 <= j <= C)的背包中的物品的最大价值，则可以得到如下的动态规划函数:
//
//(1)   V(i, 0) = V(0, j) = 0
//
//(2)   V(i, j) = V(i - 1, j)  j<wi
//
//V(i, j) = max{ V(i - 1, j), V(i - 1, j - wi) + vi) } j>wi
//
//(1)式表明：如果第i个物品的重量大于背包的容量，则装人前i个物品得到的最大价值
//和装入前i - 1个物品得到的最大价是相同的，即物品i不能装入背包；
//第(2)个式子表明:如果第i个物品的重量小于背包的容量，则会有一下两种情况：
//(a)如果把第i个物品装入背包，则背包物品的价值等于第i - 1个物品装入容量位
//j - wi 的背包中的价值加上第i个物品的价值vi;
//(b)如果第i个物品没有装入背包，则背包中物品价值就等于把前i - 1个
//物品装入容量为j的背包中所取得的价值。显然，取二者中价值最大的作
//为把前i个物品装入容量为j的背包中的最优解。
int KnapSack(int n, int w[], int v[], int x[], int C)
{
	int i, j;
	for (i = 0; i <= n; i++)
		V[i][0] = 0;
	for (j = 0; j <= C; j++)
		V[0][j] = 0;
	for (i = 1; i <= n - 1; i++)   //因为物品为0，已经初始化了，所以从1开始
		//也就是说 从a 装不装开始
									
	for (j = 0; j <= C; j++)
	if (j<w[i])
		V[i][j] = V[i - 1][j];
	else
		V[i][j] = max(V[i - 1][j], V[i - 1][j - w[i]] + v[i]);
	j = C;
	for (i = n - 1; i >= 1; i--)
	{
		if (V[i][j]>V[i - 1][j])   //这是利用最大值来确定 i是否装入
			//生成解的时候是正向生成，还原的时候是逆向的

			//一定会有物品装入，所以背包容量一定会减小，这里用一个标记数组
			//进行标记

			//由于构建的时候采用贪心策略所以，只有用前后比较的方法
			//才能找出当前子问题的解 是由递归方程的哪一个字部分确定
			//选中则进行标记，否则 进行另一部分的探索，

			//实际上就是矩阵中一条线走向的问题，一条从矩阵边缘
			//走向最终问题的线，最后找出这条线来
		{
			x[i] = 1;
			j = j - w[i];
		}
		else
			x[i] = 0;
	}
	printf("选中的物品是:\n");
	for (i = 0; i<n; i++)
		printf("%d ", x[i]);
	printf("\n");
	return V[n - 1][C];

}

//01 背包是采取动态规划的思想，保留那些重复计算的子问题，从而找出
//问题的解，动态规划的形式是递归子问题 及有一个递归表达式，
//然后有一直初始一直的数据作为最开始问题的解，这些最开始问题的解
//都是可以认为分析出来或者是问题已经给出，这样就像搭积木一般
//逐渐从底层累计找到对应问题的解，解矩阵中没有用到的重复数据
//就像虚化的积木一般，他是存在的，只不过在用不到，所以就虚化了
void main()
{
	int s;//获得的最大价值
	int w[15];//物品的重量
	int v[15];//物品的价值
	int x[15];//物品的选取状态
	int n, i;
	int C;//背包最大容量
	n = 5;
	printf("请输入背包的最大容量:\n");
	scanf("%d", &C);

	printf("输入物品数:\n");
	scanf("%d", &n);
	printf("请分别输入物品的重量:\n");
	for (i = 0; i<n; i++)
		scanf("%d", &w[i]);

	printf("请分别输入物品的价值:\n");
	for (i = 0; i<n; i++)
		scanf("%d", &v[i]);

	s = KnapSack(n, w, v, x, C);

	printf("最大物品价值为:\n");
	printf("%d\n", s);


}